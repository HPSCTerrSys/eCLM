from collections import OrderedDict
from io import StringIO

def lnd_nl_groups() -> list:
    """
    Namelist groups sorted in the same order as the lnd_in namelist generated by CLM5.
    """
    return ["clm_inparm",
            "ndepdyn_nml",
            "popd_streams",
            "urbantv_streams",
            "light_streams",
            "soil_moisture_streams",
            "lai_streams",
            "atm2lnd_inparm",
            "lnd2atm_inparm",
            "clm_canopyhydrology_inparm",
            "cnphenology",
            "clm_soilhydrology_inparm",
            "dynamic_subgrid",
            "cnvegcarbonstate",
            "finidat_consistency_checks",
            "dynpft_consistency_checks",
            "clm_initinterp_inparm",
            "century_soilbgcdecompcascade",
            "soilhydrology_inparm",
            "luna",
            "friction_velocity",
            "mineral_nitrogen_dynamics",
            "soilwater_movement_inparm",
            "rooting_profile_inparm",
            "soil_resis_inparm",
            "bgc_shared",
            "canopyfluxes_inparm",
            "aerosol",
            "clmu_inparm",
            "clm_soilstate_inparm",
            "clm_nitrogen",
            "clm_snowhydrology_inparm",
            "cnprecision_inparm",
            "clm_glacier_behavior",
            "crop",
            "irrigation_inparm",
            "ch4par_in",
            "clm_humanindex_inparm",
            "cnmresp_inparm",
            "photosyns_inparm",
            "cnfire_inparm",
            "cn_general",
            "nitrif_inparm",
            "lifire_inparm",
            "ch4finundated",
            "clm_canopy_inparm"]

def nl_to_str(nl_obj: dict, group_name: str = None, sort_groups = False) -> str:
    fortran_nml = StringIO()

    def convert_nl_group(group_name: str, params: dict):
        nonlocal fortran_nml
        p = OrderedDict(sorted(params.items(), key=lambda t: t[0]))
        fortran_nml.write("&" + group_name + "\n")
        for key, value in p.items():
            new_value = to_fortran_type(value)
            fortran_nml.write(" {} = {}\n".format(key, new_value))
        fortran_nml.write("/\n")

    if group_name is None:
        if sort_groups:
            nl = OrderedDict(sorted(nl_obj.items(), key=lambda t: t[0]))
            for group, params in nl.items():
                convert_nl_group(group, params)
        else:
            groups_added = []
            for group in lnd_nl_groups():
                if group in nl_obj:
                    groups_added.append(group)
                    convert_nl_group(group, nl_obj[group])
                else:
                    convert_nl_group(group, {})
            if len(groups_added) < len(nl_obj.keys()):
                for group, params in nl_obj.items():
                    if group not in groups_added:
                        convert_nl_group(group, params)
    elif group_name in nl_obj:
        convert_nl_group(group_name, nl_obj[group_name])
    return fortran_nml.getvalue()
    
def to_fortran_type(obj) -> str:
    if isinstance(obj, bool):
        value = ".true." if obj else ".false."
    elif isinstance(obj, str):
        value = "'{}'".format(obj)
    elif isinstance(obj, list):
        if isinstance(obj[0], str):
            value = ", ".join("'{}'".format(s) for s in obj)
        else:
            value = ", ".join(str(s) for s in obj)
    else:
        value = str(obj)
    return value